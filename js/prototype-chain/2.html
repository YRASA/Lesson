<!--
 * @Author: Zzceaon
 * @Date: 2020-06-20 22:35:40
 * @LastEditTime: 2020-06-21 00:10:49
 * @LastEditors: Please set LastEditors
 * @Description: 原型链
 * @FilePath: \Course\js\prototype-chain\2.html
--> 
<script>
  // Object Array String Boolean Function ...
  let obj2 = new Object()
  let str = '123'
  let b = true
  function foo(x, y) {
    return x + y
  }
  let foo1 = new Function('x', 'y', 'return x + y')
  console.log(foo1(1, 2))

  // 内置的类
  // 讨论 原型的指向关系
  console.log(Function.__proto__ === Function.prototype)
  console.log(Object.__proto__ === Function.prototype)

  console.log(Function.__proto__ === Function.prototype)
  // instanceof 谁是谁的实例 谁继承谁
  // instanceof 原理:
  // obj instanceof Constructor
  // 就是判断 左边这个对象(obj) 它的原型链上面 有没有出现过 Constructor.prototype 这个对象
  // 查找左边这个对象的原型链 看原型链有没有出现过 Constructor.prototype 这个对象, 如果出现了 返回true
  // 如果找到原型链的顶端还没有找到 返回false
  // 鸡和蛋
  // obj.__proto__.__proto__.__proto__......
  // 如果用instanceof 那么 他俩就成了鸡和蛋的问题
  console.log(Object instanceof Function)  // true
  // 原因是因为: 查找Object的原型链可以找到 Function.prototype
  console.log(Function instanceof Object)  // true
  // 原因是因为: 查找Function的原型链可以找到 Object.prototype

  console.log(String.__proto__ === Function.prototype)
  console.log(Boolean.__proto__ === Function.prototype)
  console.log(Array.__proto__ === Function.prototype)
  console.log(Number.__proto__ === Function.prototype)

  function foo() {}
  foo.call
  foo.apply
  let arr = [0, 1, 2]
  arr.push
  arr.shift
  // call apply 来自于哪里
  // 函数上面的 api 定义 Function.prototype
  foo.__proto__ == Function.prototype
  // 数组上面的 api 定义 Array.prototype
  arr.__proto__ == Array.prototype
</script>